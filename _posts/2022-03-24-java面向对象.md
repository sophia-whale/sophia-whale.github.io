---
layout: post
title: Java面向对象
date: 2022-03-24 20:19 +0800
author:
  name: Sophia-whale
  link: https://github.com/sophia-whale
description:
categories: [Java, Object-Oriented]
tags: [java]
math: true
mermaid: true
---
构造方法

默认为无参的构造方法

构造方法与普通方法的区别

* 构造方法的名称必须与所在的类的名称相同。
* 构造方法没有返回类型，包括没有 void。
* 构造方法通过 new 操作符调用，通过调用构造方法创建对象。

构造方法不能被子类重写！
原因：重写是发生在继承阶段，重写是要求方法名保持一致，又因为构造方法名必须与类名保持一致，因此子类无法重写构造方法。（如果能重写，则子类的类名必须与父类类名一致，这显然是不可以的）


静态和实例

外部调用

从外部调用静态的类成员时，可以通过类名调用，也可以通过对象名调用。从外部调用实例的类成员，则只能通过对象名调用。

内部访问

静态方法只能访问静态的类成员，不能访问实例的类成员。实例方法既可以访问实例的类成员，也可以访问静态的类成员。因为实例的类成员是依赖于具体对象（实例）的，而静态方法不依赖于任何实例，因此不存在静态方法直接或间接地访问实例或实例的类成员的情况。


初始化块

初始化块可以分成静态初始化块和非静态初始化块，前者在加载类时被隐式调用，后者在创建对象时被隐式调用。

存在继承关系的初始化块的执行顺序
如果存在继承关系，则在对子类进行类的加载和创建对象时，也会对父类进行类的加载和创建对象。执行顺序仍然是静态初始化块、非静态初始化块、构造器，由于存在继承关系，因此情况较为复杂。

对于两个类的情况，即一个父类和一个子类，执行顺序如下。

执行父类的静态初始化块。

执行子类的静态初始化块。

执行父类的非静态初始化块。

执行父类的构造器。

执行子类的非静态初始化块。

执行子类的构造器。


关键字this
