<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://sophia-whale.github.io//</id><title>Whale's blog</title><subtitle>This blog is dedicated to documenting the difficult learning journey of a rookie.</subtitle> <updated>2024-04-09T16:45:53+08:00</updated> <author> <name>sophia whale</name> <uri>https://sophia-whale.github.io//</uri> </author><link rel="self" type="application/atom+xml" href="https://sophia-whale.github.io//feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://sophia-whale.github.io//"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2024 sophia whale </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>OBCA基础知识</title><link href="https://sophia-whale.github.io//posts/obca%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="alternate" type="text/html" title="OBCA基础知识" /><published>2024-04-09T16:17:00+08:00</published> <updated>2024-04-09T16:17:00+08:00</updated> <id>https://sophia-whale.github.io//posts/obca%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id> <content src="https://sophia-whale.github.io//posts/obca%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" /> <author> <name>{"name"=>"Sophia-whale", "link"=>"https://github.com/sophia-whale"}</name> </author> <category term="OBCA" /> <category term="Basic Grammar" /> <summary> OBCA 一、分布式数据库 传统数据库：高成本，难扩展 分布式数据库：数据高可靠、服务高可用、线性扩容、低成本、全局一致性、对业务透明 object-database-example 二、OceanBase object-database-example 基本概念： 集群：Zone-1：n Zone：OBServer-1：n，在每一个Zone选择一台Server部署总控服务（rootService） OBServer包含多个租户，每个租户之间相互隔离（内存、CPU、数据） 每个租户拥有n个资源池 【注】：一台OBServer上只能放置一个租户的一个资源块，当一台OBServer宕机时，会迁移到同一个Zone下的其他Server上，同时，为保证租户资源的负载均衡，会在一个Zone内动态分配各Server中Unit的数量 OB集群部署： 在不少... </summary> </entry> <entry><title>Docker basics</title><link href="https://sophia-whale.github.io//posts/docker-basics/" rel="alternate" type="text/html" title="Docker basics" /><published>2023-03-18T19:47:00+08:00</published> <updated>2023-03-18T19:47:00+08:00</updated> <id>https://sophia-whale.github.io//posts/docker-basics/</id> <content src="https://sophia-whale.github.io//posts/docker-basics/" /> <author> <name>{"name"=>"Sophia-whale", "link"=>"https://github.com/sophia-whale"}</name> </author> <category term="Docker" /> <category term="basics" /> <summary> Docker概述 为跨平台的开发部署环境带来了便利。轻量 隔离 跨平台 1.0 Docker背景 虚拟机缺点 启动慢 资源占用多 比较Docker和虚拟机技术的不同： 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了 每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响 DevOps 应用可以更快速的交付和部署 更易扩容升级 更易运维 更高效地利用系统资源 1.1 Docker运行流程 docker开始运行 在本机寻找镜像 若镜像存在，则使用镜像运行；若不存在，则在远程仓库中下载镜像 若镜像在远程仓库中存在，则将镜像下载到本地；若不存在，则返回错误，找不到... </summary> </entry> <entry><title>Java面向对象</title><link href="https://sophia-whale.github.io//posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="alternate" type="text/html" title="Java面向对象" /><published>2022-03-24T20:19:00+08:00</published> <updated>2022-03-24T20:19:00+08:00</updated> <id>https://sophia-whale.github.io//posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id> <content src="https://sophia-whale.github.io//posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" /> <author> <name>{"name"=>"Sophia-whale", "link"=>"https://github.com/sophia-whale"}</name> </author> <category term="Java" /> <category term="Object-Oriented" /> <summary> 构造方法 默认为无参的构造方法 构造方法与普通方法的区别 构造方法的名称必须与所在的类的名称相同。 构造方法没有返回类型，包括没有 void。 构造方法通过 new 操作符调用，通过调用构造方法创建对象。 构造方法不能被子类重写！ 原因：重写是发生在继承阶段，重写是要求方法名保持一致，又因为构造方法名必须与类名保持一致，因此子类无法重写构造方法。（如果能重写，则子类的类名必须与父类类名一致，这显然是不可以的） 静态和实例 外部调用 从外部调用静态的类成员时，可以通过类名调用，也可以通过对象名调用。从外部调用实例的类成员，则只能通过对象名调用。 内部访问 静态方法只能访问静态的类成员，不能访问实例的类成员。实例方法既可以访问实例的类成员，也可以访问静态的类成员。因为实例的类成员是依赖于具体对象（实例）的，而静态方法不依赖于任何实例，因此不存在静态方法直... </summary> </entry> <entry><title>Java基础知识</title><link href="https://sophia-whale.github.io//posts/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="alternate" type="text/html" title="Java基础知识" /><published>2022-03-24T19:23:00+08:00</published> <updated>2022-03-24T19:23:00+08:00</updated> <id>https://sophia-whale.github.io//posts/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id> <content src="https://sophia-whale.github.io//posts/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" /> <author> <name>{"name"=>"Sophia-whale", "link"=>"https://github.com/sophia-whale"}</name> </author> <category term="Java" /> <category term="Basic Grammar" /> <summary> 基本数据结构 字符型 char 数值型 byte short int long float double 布尔型 boolean 方法 语法结构：方法包括方法头和方法体，方法头又可以分成修饰符、返回值类型、方法名和参数列表，因此方法包括 5 个部分。方法名和参数表共同构成 方法签名 。 参数 方法重载 递归 </summary> </entry> <entry><title>Chapter 2 Process Management</title><link href="https://sophia-whale.github.io//posts/chapter-2-process-management/" rel="alternate" type="text/html" title="Chapter 2 Process Management" /><published>2022-03-09T09:32:00+08:00</published> <updated>2022-03-09T09:32:00+08:00</updated> <id>https://sophia-whale.github.io//posts/chapter-2-process-management/</id> <content src="https://sophia-whale.github.io//posts/chapter-2-process-management/" /> <author> <name>{"name"=>"Sophia-whale", "link"=>"https://github.com/sophia-whale"}</name> </author> <category term="Operating System" /> <category term="Chapter 1 Operating System Overview" /> <summary> 进程基本概念与状态切换 1.1 基本概念 进程是可并发执行的程序在某个数据集合中进行的一次计算活动，是操作系统分配系统CPU，进行资源调度的最小单位，线程是任务调度和执行的最小单位。 进程映像：程序段、数据段、PCB Process Control Block（PCB）进程控制块：pid时进程唯一性的标记，PCB是进程存在的唯一标志。系统通过进程的PCB了解进程的状态和相关信息，从而对进程进行管理。PCB包含进程描述信息、资源分配信息、处理机控制信息。 1.2 状态切换模型 三状态模型 五状态模型 七状态模型 [注]挂起等待态→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态。 进程控制 2.1 进程创建 为进... </summary> </entry> </feed>
